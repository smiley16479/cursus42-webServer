# Mettre le config_checker ds le server.cpp
# Verifier pourquoi quingli utilise "host" au lieu de server_name et port au lieu de listen
# Les IP multiple ds le selectServer de jacob pourraient elles venir du pipelining ou concurrency 6.3.2 rfc 7230 ?

# commit: d822b03f -> non le header response 'Content-Disposition : inline' ne permet l'affichage directement ds le navigateur
# // IF YOU WANT THE BROWSER TO READ WITHOUT ASKING TO DOWNLOAD IT, DON'T ADD THE TRAILING '/' OR DON'T MENTION ITS FILE TYPE

• on ne renvoi pas de status_error adapté ds la startLine si le check de la taille du fichier est mauvaise (409 -411)
• On ne doit pas renvoyer les fichier POST ou PUT ds la reponse apparement (a modifier) 
• On doit faire passer les attributs de request_handler correspondant aux clients ds les ... clients DONE (mais tjrs _response a virer des cgi)
• On doit faire une lookUp table pour les type de request (Arthur l'a fait regarder son exemple) DONE (mais à ajuster avec les enum)
• On doit finir les system de réponse en plusieurs fois avec EPOLLOUT
• On doit raccorder les cgi
• On doit tester le server

Voici les commandes utilisées av le docker Nginx :
curl -X DELETE  127.0.0.1:8080/to_erase										-> 404 si n'exite pas 204 si effacement réussi
curl -X POST  127.0.0.1:8080/test.php -v									-> 404 si le fichier n'existe pas sur le server
curl -X POST  127.0.0.1:8080/exemple.php -v									-> 200 si le fichier existe sur le server 502 si php-fpm7.4 n'est pas lancé
curl -X GET  127.0.0.1:8080/exemple.php -v									-> 200 si le fichier existe sur le server 502 si php-fpm7.4 n'est pas lancé
curl -X PUT -F 'file=@compil.sh' 127.0.0.1:8080/create_to_erase -v			-> 201 creer le fichier (compil.sh) sur le server av le nom : create_to_erase


curl -X POST -F 'create_to_erase=@Makefile' 127.0.0.1:8080/exemple.php -v -> ?